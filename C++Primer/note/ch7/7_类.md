* 在C++中, 使用类定义自己的数据类型, 通过定义新的类型来反映待解决问题中的各种概念, 可以更容易地编写, 调试和修改程序.
* 类的基本思想是**数据抽象**, 和**封装**. 数据抽象是一种依赖于**接口**和**实现**分离的编程(以及设计)技术. 
* 类的接口包括用户能执行的操作, 类的实现则包括类的数据成员, 负责接口实现的函数体以及定义类所需的各种私有函数.
* 类想要实现数据抽象和封装, 需要先定义一个**抽象数据类型**, 在抽象数据类型中, 由类的设计者负责考虑类的实现过程, 使用该类的程序员则只需要抽象地思考类型做了什么, 而无需了解它是如何做到的.

# 7.1 定义抽象数据类型
* 类的用户是程序员, 无需刻意区分应用程序的用户以及类的用户
* 定义在类内部的函数是隐式的inline函数.
* **成员函数内部对类成员的直接访问**都被看做this的隐式引用
* 默认情况下, **this的类型是指向<u>类类型非常量版本</u>的常量指针**. 如: `Sales_data *const`
* 依上述, 在默认情况下, 不能把this绑定到一个常量对象上, 这意味着, 用户不能在一个常量对象上调用普通的成员函数, 若实现此种功能, 则this指针的类型应为`const Sales_data *const`, 但this是隐式的, 并不会出现在参数列表中.
* C++允许把const关键字放在成员函数的参数列表之后, 表示this是一个指向常量的指针, 像这样使用const的成员函数被称作**常量成员函数**
* <u>常量对象, 以及常量对象的引用或指针都只能调用常量成员函数.</u>
  ```cpp
  struct Sales_data {
    std::string isbn() const {return bookNo;}
  };
  ````

* 在默认情况下, 拷贝类的对象其实拷贝的是对象的数据成员

## 7.1.4 构造函数
* 构造函数可以重载
* 不同于其他成员函数, 构造函数不能被声明成`const`, 在创建类的const对象时, 直到构造函数完成初始化过程, 对象才能真正取得const属性, 因此, 构造函数在const对象的构造过程中, 可以向其写值.
* 只有当类没有声明任何构造函数时, 编译器才会自动地生成默认构造函数.
  ```cpp
  struct Sales_data {
  public:
    Sales_data() = default;
    Sales_data(const std::string &s): bookNo(s) {}
    Sales_data(const std::string &s, unsigned n, double p):
      bookNo(s), units_sold(n), revenue(p*n) {}
    Sales_data(std::istream &);

    std::string isbn() const {return bookNo;}
    Sales_data& combine(const Sales_data&);

  private:
    double avg_price() const;
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
  };
  ```
* 在C++11新标准中, 如果需要默认的行为,可以通过在参数列表后面写上`= default`来要求编译器生成默认构造函数.


## 7.1.5 拷贝、赋值和析构
* 当vector对象(或者数组)被销毁时, 存储在其中的对象也会被销毁.
* 当使用了赋值运算符时, 会发生对象的赋值操作, 赋值运算符不会创建临时对象, 而是把右侧运算对象的值赋给左侧运算对象.

***

# 7.2 访问控制与封装
* 定义在**public**说明符之后的成员在整个程序内可被访问, public成员定义类的接口.
* 定义在**private**说明符之后的成员可以被类的成员函数访问, 但是不能被使用该类的代码访问, private部分封装(即隐藏)了类的实现细节.
* 每个访问说明符之后直到下一个访问说明符或者类的结束位置的成员都属于该访问说明符所控制的范围.
</br>
* **class**和**struct**的唯一区别在于默认的访问权限不同, class默认是private, struct默认是public.
  
## 7.2.1 友元
* 类可以授予其他类或者函数访问它的非公有成员的权限, 这种被授予访问权限的类或者函数称为友元.
* 在一个函数声明前加上关键字`friend`即可将该函数声明为友元, 友元函数不受类访问控制的约束.
* 一般建议在类定义开始或结束钱的位置集中声明友元.

# 7.3 类的其他特性
* **可变数据成员**(mutable data member)永远不会是const, 即使它在类的const成员函数中, 或是const对象的成员. 使用方法: 在数据成员的声明语句后面加上关键字`mutable`.
* 当提供一个类内初始值时, 必须以符号`=`或者花括号`{}`的形式提供初始值, 不能使用括号`()`的形式.
* <u>一个const成员函数如果以引用的形式返回this指针, 那么它的返回类型将是一个常量引用.</u>
* 通过区分成员函数是否是const, 可以对其进行重载, 使用重载的函数调用时, 编译器会根据调用对象是否为常量版本, 来决定调用哪个版本.
* 每个类定义了唯一的类型, 对于两个类来说, 即使它们的成员完全一样, 这两个类也不是同一种类型.
* 可以仅仅声明类, 而暂时不定义它的成员, 这种声明称为**前向声明**(forward declaration).
  * 如`class Screen;`就是一个前向声明.
  * 此时编译器已知Screen是一个类类型, 但不清楚它包含哪些成员.
  * 此时可以定义指向这种类型的指针或引用, 也可以声明(但不能定义)以这种类型为参数或者返回类型的函数.
</br>
* 类可以把其他类定义成友元, 也可以把其他类(之前已定义过的)的成员函数定义成友元. 友元函数能定义在类的内部, 这样的函数是隐式内联的.
* 友元关系不存在传递性, 即使类B是类A的友元, 类C是类B的友元, 也不能说类C是类A的友元.
* 重载函数的名字相同, 但是不是同一个函数, 故友元函数需要分别声明.

## 7.4.1 名字查找与类的作用域
* 编译器处理完类中的全部声明后才会处理成员函数的定义.
* **在类中**, 如果成员使用了外层作用域中的某个名字, 而该名字**代表一种类型**, 则类不能在之后重新定义该名字.
* 类型名的定义通常出现在类的开始处, 这样就能确保所有使用该类型的成员都出现在类名的定义之后.
* 函数的参数位于函数作用域内.

***
 
# 7.5 构造函数再探
* 如果成员是const, 引用, 或者属于某种未提供默认构造函数的类类型, 则必须通过构造函数初始值列表的方式为这些成员提供初值.
* 构造函数初始值列表中初始值的前后位置不会影响实际的初始化顺序, 成员的初始化顺序与它们在类定义中出现的顺序一致.
* <u>**最好令构造函数初始值的顺序与成员声明的顺序保持一致**, 而且如果可能的话, 尽量避免使用某些成员初始化其他成员.</u>
* 如果一个构造函数为所有参数都提供了默认实参, 则它实际上也定义了默认构造函数.

## 7.5.2 委托构造函数
* C++11新标准扩展了构造函数初始化值的功能, 使得可以定义**委托 构造函数**, 即一个构造函数可以调用另一个构造函数来完成部分工作.
  ```cpp
  class Sales_data {
  public:
    // 非委托构造函数舒春松对应的实参初始化成员
    Sales_data(const std::string &s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p*n) { }

    // 其余的构造函数全都委托给另一个构造函数
    Sales_data() : Sales_data("", 0, 0) { }
    Sales_data(const std::string &s) : Sales_data(s, 0, 0) { }
    Sales_data(std::istream &is) : Sales_data() { read(is, *this); }
  };
  ```

## 7.5.4 隐式的类类型转换
* 编译器只会自动地执行**一步**类型转换.
* 可以通过将构造函数声明为**explicit**来禁止隐式转换.
  ```cpp
  class Sales_data {
  public:
    Sales_data() = default;
    explicit Sales_data(const std::string &s) : bookNo(s) { }
    explicit Sales_data(std::istream &is = std::cin) { read(is, *this); }
  };
  ```

## 7.5.5 聚合类
* 聚合类是一种特殊的类, 其特点是所有成员都是public的, 没有定义任何构造函数, 没有类初始值, 没有基类, 也没有virtual函数.
* 数据成员都是字面值类型的聚合类, 称为**字面值常量类**.
* 若符合以下几个要求也是**字面值常量类**:
  * 数据成员都必须是字面值类型
  * 类必须至少含有一个constexpr构造函数
  * 如果一个数据成员含有类初始值, 则内置类型成员的初始值必须是一条常量表达式, 或者如果成员属于某种类型, 则初始值必须使用成员自己的constexpr构造函数.
  * 类必须使用析构函数的默认定义, 该成员负责销毁类的对象.

* 一个字面值常量类必须至少提供一个constexpr构造函数, 该构造函数的参数必须是常量表达式, 且必须使用类内初始值来初始化数据成员.

***

# 7.6 类的静态成员
* 类的静态成员是属于类的, 而不是属于类的某个对象的成员.
* 类的静态成员存在于任何对象之外, 对象中不包含任何与静态数据成员有关的数据.
* 静态成员函数也不与任何对象绑定在一起, 它们只能访问类的静态成员, 不包含this指针.
* 直接使用作用域运算符`::`直接访问静态成员, 可以使用类的对象, 引用或者指针来访问静态成员.
* 在其他成员函数内, 可以不通过作用域运算符来访问静态成员, 因为编译器会自动地将类名添加到静态成员的名字前面.
* 在类的外部定义静态成员时, 不能重复static关键字, 该关键字值出现在类内部的声明语句.
* 静态数据成员不是由构造函数初始化的.
* 静态数据成员的类型可以就是它所属的类类型.
* 可以使用静态成员作为默认实参.