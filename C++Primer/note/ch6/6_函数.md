# 6.1 函数基础
* 一个典型的函数定义包括: 返回类型, 函数名, 形参列表(0个或多个), 函数体
* 通过**调用运算符**来调用函数, 函数名后面跟着一对圆括号, 圆括号中包含实参列表, 使用实参初始化函数的形参
* 函数的调用完成两项工作: 
  1. 用实参初始化函数对应的形参
  2. 将控制权转移给被调用的函数, 此时**主调函数**的执行被暂停, 直到被调用的函数执行完毕, 主调函数才恢复执行

* 函数的返回类型: 
  * 一种特殊的返回类型是void, 表示函数不返回任何值
  * 函数的返回类型不能是数组类型或函数类型, 但可以是指向数组或函数的指针

## 6.1.1 局部对象
* 在C++中, 名字有作用于, 对象有生命周期
  * 名字的作用域是程序文本的一部分, 名字在其中可见
  * 对象的生命周期是程序执行过程中该对象存在的一段时间

* 形参和函数体内定义的变量都是局部变量, 它们在函数执行过程中创建, 在函数执行结束时销毁
* 在所有函数体之外定义的对象存在于程序的整个执行过程中, 它们在程序开始执行时创建, 在程序结束时销毁, 局部变量的生命周期依赖于定义的方式

* **自动对象**
  * 把只存在于执行期间的对象称为**自动对象**, 当块执行结束后, 块中创建的自动对象的值就变成未定义的了, 形参即为一种自动对象

* **局部静态对象**: 将局部变量定义成`static`类型获得此类对象

## 6.1.2 函数声明(函数原型)
* 函数声明无需函数体, 但必须包含函数的返回类型, 函数名和形参列表
* 函数声明可以省略形参名, 但必须指定形参的类型

# 6.2 参数传递
* 每次调用函数时, 都会重新创建函数的形参, 并用传入的实参对形参进行初始化
* 当形参是引用类型时, 称为函数对应的实参被**引用传递**, 和其他引用一样, 引用形参也是它绑定的对象的别名, 也就是说, **引用形参是它对应的实参的别名**
* 当实参的值被拷贝给形参时, **形参和实参是两个互相独立的对象**, 称这样的实参被**值传递**

## 6.2.1 传值参数
* 当初始化一个非引用类型的变量时, 初始值被拷贝给变量, 这种拷贝过程称为**拷贝初始化**, 此时, 拷贝的是实参的值, 而非实参变量本身, 对变量的改动不会影响初始值(实参).

* 指针形参
  * 指正的行为和其他非引用类型一样, 也是值传递, 但是指针的值是对象的地址, 因此, 指针形参的值是实参的地址, 也就是说, 指针形参是实参的别名.
  > 因为指针使我们可以间接地访问它所指的对象, 所以通过指针可以修改它所指的对象的值
  > 在C语言中, 常常使用指针类型的形参访问函数外部的变量, 但是在C++中, 一般不这样做, 因为C++中有引用类型, 可以直接访问函数外部的变量, 而且引用类型更安全

## 6.2.2 传引用参数
* 对于引用的操作实际上是作用在引用所引的对象上的, 因此, 通过引用形参可以直接修改实参的值
* 因为引用的特性, 可以**使用引用从而避免对象对象的拷贝**
  * 比如某函数需要比较两个string对象的大小, 但是不需要改变这两个对象的值, 此时, 可以将这两个string对象的引用作为参数, 这样就可以避免拷贝这两个string对象
  `bool isShorter(const string &s1, const string &s2) { return s1.size() < s2.size(); }`