# 6.1 函数基础
* 一个典型的函数定义包括: 返回类型, 函数名, 形参列表(0个或多个), 函数体
* 通过**调用运算符**来调用函数, 函数名后面跟着一对圆括号, 圆括号中包含实参列表, 使用实参初始化函数的形参
* 函数的调用完成两项工作: 
  1. 用实参初始化函数对应的形参
  2. 将控制权转移给被调用的函数, 此时**主调函数**的执行被暂停, 直到被调用的函数执行完毕, 主调函数才恢复执行

* 函数的返回类型: 
  * 一种特殊的返回类型是void, 表示函数不返回任何值
  * 函数的返回类型不能是数组类型或函数类型, 但可以是指向数组或函数的指针

## 6.1.1 局部对象
* 在C++中, 名字有作用于, 对象有生命周期
  * 名字的作用域是程序文本的一部分, 名字在其中可见
  * 对象的生命周期是程序执行过程中该对象存在的一段时间

* 形参和函数体内定义的变量都是局部变量, 它们在函数执行过程中创建, 在函数执行结束时销毁
* 在所有函数体之外定义的对象存在于程序的整个执行过程中, 它们在程序开始执行时创建, 在程序结束时销毁, 局部变量的生命周期依赖于定义的方式

* **自动对象**
  * 把只存在于执行期间的对象称为**自动对象**, 当块执行结束后, 块中创建的自动对象的值就变成未定义的了, 形参即为一种自动对象

* **局部静态对象**: 将局部变量定义成`static`类型获得此类对象

## 6.1.2 函数声明(函数原型)
* 函数声明无需函数体, 但必须包含函数的返回类型, 函数名和形参列表
* 函数声明可以省略形参名, 但必须指定形参的类型

# 6.2 参数传递
* 每次调用函数时, 都会重新创建函数的形参, 并用传入的实参对形参进行初始化
* 当形参是引用类型时, 称为函数对应的实参被**引用传递**, 和其他引用一样, 引用形参也是它绑定的对象的别名, 也就是说, **引用形参是它对应的实参的别名**
* 当实参的值被拷贝给形参时, **形参和实参是两个互相独立的对象**, 称这样的实参被**值传递**

## 6.2.1 传值参数
* 当初始化一个非引用类型的变量时, 初始值被拷贝给变量, 这种拷贝过程称为**拷贝初始化**, 此时, 拷贝的是实参的值, 而非实参变量本身, 对变量的改动不会影响初始值(实参).

* 指针形参
  * 指正的行为和其他非引用类型一样, 也是值传递, 但是指针的值是对象的地址, 因此, 指针形参的值是实参的地址, 也就是说, 指针形参是实参的别名.
  > 因为指针使我们可以间接地访问它所指的对象, 所以通过指针可以修改它所指的对象的值
  > 在C语言中, 常常使用指针类型的形参访问函数外部的变量, 但是在C++中, 一般不这样做, 因为C++中有引用类型, 可以直接访问函数外部的变量, 而且引用类型更安全

## 6.2.2 传引用参数
* 对于引用的操作实际上是作用在引用所引的对象上的, 因此, 通过引用形参可以直接修改实参的值
* 因为引用的特性, 可以**使用引用从而避免对象对象的拷贝**
  * 比如某函数需要比较两个string对象的大小, 但是不需要改变这两个对象的值, 此时, 可以将这两个string对象的引用作为参数, 这样就可以避免拷贝这两个string对象
  例:
  ```cpp
  // 比较两个string对象的长度
  bool isShorter(const string &s1, const string $s2)
  {
    return s1.size() < s2.size();
  }
  ```
* 使用引用形参返回额外信息, 可以使用引用形参实现函数及返回多个结果.

## 6.2.3 const形参和实参
* 在实参初始化形参时, 会忽略掉顶层const, 在定义相同名字的函数时, 参数列表忽略掉const的差别
* C++允许使用字面值初始化常量引用.
* **应该尽量使用常量引用**
  * 把函数不会改变的形参定义成(普通的)引用是一种比较常见的错误, 这么做带给函数的调用者一个误导, 即函数可以修改他的实参的值
  * 使用引用而非常量引用也**会极大地限制函数所能接收的实参类型**, 无法把const对象, 字面值或者需要类型转换的对象传递给普通的引用形参

## 6.2.4 数组形参
* 数组包含两个特殊性质:
  1. 不允许拷贝数组(3.5.1)
  2. 在使用数组时(通常)会将其转换为指向首元素的指针(3.5.3)

* 因为数组会转换成指针, 所以当我们为函数传递一个数组时, 实际上传递的是指向数组首元素的指针.
* 因为数组是以指针的形式传递给函数的, 所以一开始函数并不知道数组的确切尺寸, 调用者应该为此提供一些额外的信息. 有三种常用的技术.
  1. 使用标记指定数组长度
    * C风格字符串存储在字符数组中, 并且在最后一个字符后面跟着一个空字符, 函数在处理C风格字符串时, 遇到空字符停止.

  2. 使用标准库规范(C++11 begin和end函数)
    * 在传递数组时, 同时传递指向数组首元素和尾后元素的指针

  3. 显式传递一个表示数组大小的形参 

## 6.2.5 main函数处理命令行选项
`int main(int argc, char **argv)`
* 第二个形参`argv`是一个数组, 它的元素是指向C风格字符串的指针
* 第一个形参`grgc`表示数组中字符串的数量
* `argv`的第一个元素指向程序的名字或者一个空字符串, 接下来的元素依次传递命令行提供的实参

## 6.2.6 含有可变形参的函数
* `initizlizer_list`形参
  * 如果函数的实参数量未知, 单数全部实参的类型都相同, 可以使用`initializer_list`类型的形参.
  * `initializer_list`是一种模板类型, 其中的元素永远是常量值, 对象包含`begin`和`end`操作函数
  * 可使用列表初始化`initializer_list`对象
  例: 
  ```cpp
  void error_mesg(initializer_list<string> il)
  {
    for(auto beg = il.begin(); beg != i.end(); ++beg)
      cout << *beg << " ";

    cout << endl;
  }
  ```

* 省略符形参
  * 省略符形参应该仅仅用于C和C++通用的类型, 大多数类型的对象在传递给省略符形参时都无法正确拷贝.
  * 省略符形参只能出现在形参列表的最后一个位置.

***

# 6.3 返回类型和return语句
* return语句终止当前正在执行的函数, 并将控制权返回到调用该函数的地方
* 在含有return语句的循环后面应该也有一条return语句, 如果没有有的话, 程序就是错误的
* 不要返回局部对象的引用或指针
* 函数的返回类型决定函数调用是否是左值. 调用一个返回引用的函数得到左值, 其他返回类型得到右值.
* C++11新标准规定, 函数可以返回花括号包围的值的列表, 如返回vector<string>, 则可以直接返回`return {"hello", "world"}`
* 主函数main在结尾处如果没有return语句, 编译器将隐式地插入一条返回0的return语句, 返回0表示执行成功, 其他返回值表示执行失败
* main函数不能调用它自己
* 数组不能被拷贝, 故函数不能返回数组, 但可以返回数组的指针或引用.

# 6.4 函数重载
* 如果同一作用域内的几个函数名字相同但形参列表不同, 称之为`重载函数`.
* main函数不能重载
* 函数声明可以省略形参的名字
* 不允许两个函数除了返回类型外其他所有要素都相同
* 一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来
* 调用重载函数时的三种可能的结果:
  1. 编译器找到一个与实参最佳匹配的函数, 并生成调用该函数的代码
  2. 找不到任何一个函数与调用的实参匹配, 此时编译器发出`无匹配`的错误信息
  3. 有多余一个函数可以匹配, 但是每一个都不是明显的最佳选择, 此时也将发生错误, 成为`二义性调用`

## 6.4.1 重载与作用域
* 如果在内层作用域中声明名字, 它将隐藏外层作用域中声明的同名实体, 在不同的作用域中无法重载函数名.
* 在C++中, 名字查找发生在类型检查之前

## 6.5.1 默认实参
* 某些函数的形参在函数的很多次调用中都被赋予一个相同的值, 此时将这个反复出现的值称为函数的默认实参. 调用含有默认实参的函数时, 可以包含该实参, 也可以省略该实参.
* 在设置默认实参时, 应将经常使用的默认值的形参放在后面.
* 默认实参声明在函数形参列表最右边, 默认实参的右侧所有形参必须都有默认值.
* 局部变量不能作为默认实参

## 6.5.2 内联函数和constexpr函数
* 将函数指定位内联函数, 通常就是将它在每个调用点上"内联地"展开. 消除函数运行时的开销.
* 在函数的返回类型前面加上关键字`inline`, 可将函数声明为内联函数
* 内联说明只是向编译器发出的一个请求, 编译器可以选择忽略这个请求

* `constexpr`函数是指能用于常量表达式的函数. 
* 定义`constexpr`函数的方法: 函数的返回类型及所有形参的类型都必须是字面值类型, 而且函数体中必须有且只有一条return语句.
* 在执行初始化任务时, 编译器把对`constexpr`函数的调用替换成其结果值, 为了能在编译过程中随时展开, `constexpr`函数被隐式地指定为内联函数.
* `constexpr`函数不一定返回常量表达式.
* 内联函数和`constexpr`函数通常定义在头文件中.

## 6.5.3 调试帮助
* `assert`是一种预处理宏.
* 格式: `assert(expr)`
* 首先对expr求值, 如果表达式为假(0), assert输出信息并终止程序的运行, 如果表达式为真(非0), assert什么也不做.
* assert的行为依赖于一个名为`NDEBUG`的预处理变量的状态, 如果定义了NEDBUG, 则assert什么也不做.
* 常用的预处理器:
  * `__FILE__`: 存放文件名的字符串字面值
  * `__LINE__`: 存放当前行号的整形字面值
  * `__TIME__`: 存放文件编译时间的字符串字面值
  * `__DATE__`: 存放文件编译日期的字符串字面值
  
# 6.6 函数匹配
见P217~P220

# 6.7 函数指针
* 函数指针指向的是函数, 而非对象
* 函数的类型由它的返回类型和形参类型共同决定, 与函数名无关.
* 当把函数名作为一个值使用时, 该函数自动地转换成指针.
* 可以直接使用指向函数的指针调用函数, 无需提前解引用指针.
* 形参可以是指向函数的指针
* `decltype`返回的结果是函数类型, 所以只有在结果前面加上*才能得到指针.
* 可返回指向函数类型的指针
  ```cpp
  int (*f1(int))(int*, int);
  // 等价于:(尾置返回类型方式)
  auto f1(int) -> int (*)(int*, int);
  ```
